window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "notnormal", "modulename": "notnormal", "kind": "module", "doc": "<h1 id=\"notnormal\">NotNormal</h1>\n\n<p>This package revolves around the <strong>NotNormal</strong> algorithm, which combines estimation and iteration to automatically extract events from (nano)electrochemical time series data.  The <a href=\"notnormal/docs/index.html\"><em>notnormal</em></a> package includes the <a href=\"notnormal/docs/notnormal/extract.html\"><em>extract</em></a>, <em>gui</em>, <a href=\"notnormal/docs/notnormal/filter.html\"><em>filter</em></a>, <a href=\"notnormal/docs/notnormal/simulate.html\"><em>simulate</em></a>, <a href=\"notnormal/docs/notnormal/reconstruct.html\"><em>reconstruct</em></a>, <a href=\"notnormal/docs/notnormal/simulate.html\"><em>simulate</em></a>, and <a href=\"notnormal/docs/notnormal/models.html\"><em>models</em></a> packages. </p>\n\n<p>The <a href=\"notnormal/docs/notnormal/extract.html\"><em>extract</em></a> package contains the functional form of the NotNormal algorithm, to be used within preexisting code or without the use of the GUI. </p>\n\n<p>The <em>gui</em> package is the GUI realisation of the algorithm along with additional functionality to aid in the extraction process. </p>\n\n<p>The <a href=\"notnormal/docs/notnormal/filter.html\"><em>filter</em></a> package contains a predictive wavelet filter built upon the estimate extraction, exploiting known event locations to maximise signal-to-noise ratios.</p>\n\n<p>The <a href=\"notnormal/docs/notnormal/simulate.html\"><em>simulate</em></a> package is a WIP and will simulate a trace based on a set number of parameters which describe the noise, baseline and event profiles.</p>\n\n<p>The <a href=\"notnormal/docs/notnormal/reconstruct.html\"><em>reconstruct</em></a> package contains methods to reconstruct noise profiles, deduce baseline influences, and reconstruct events with further shape-based clustering and augmentation functionality.</p>\n\n<p>The <a href=\"notnormal/docs/notnormal/models.html\"><em>models</em></a> package contains dataclasses used internally and for returning results from functions within the entire package.</p>\n\n<h2 id=\"gui-quickstart\">GUI Quickstart</h2>\n\n<ol>\n<li>Click <strong>Browse</strong> -> upon loading, the Z-score will be calculated automatically based on the sample size</li>\n<li>Click <strong>Estimate</strong> -> this will estimate the cutoff and event direction for iteration</li>\n<li>Click <strong>Iterate</strong> -> this will produce the final results</li>\n<li>Click <strong>Save</strong> -> this will produce a CSV file containing the event profiles</li>\n</ol>\n\n<h2 id=\"faq\">FAQ</h2>\n\n<p><strong>Q.</strong> What is a Bounds Filter?<br />\n<strong>A.</strong> This will help determine bounding for long-tailed events, it is only worth changing if inadequate bounding  is identified on conclusion of iteration.</p>\n\n<p><strong>Q.</strong> My estimate is attenuating events too much<br />\n <strong>A.</strong> Reduce the Estimate Cutoff. </p>\n\n<p><strong>Q.</strong> My estimate is bounding my events badly<br />\n <strong>A.</strong> Increase the Estimate Cutoff.</p>\n\n<p><strong>Q.</strong> I want to use a different Threshold Window size<br />\n <strong>A.</strong> Nice! But be informed, an experiment was conducted to determine this was the ideal size for the estimate.</p>\n\n<p><strong>Q.</strong> I want to use a lower Z-score<br />\n <strong>A.</strong> This will produce false positives presuming a perfectly normal sample after transformation. It is a good job the estimated number of false positives can be found in the results window upon completion of iteration. What you do with this information remains to be seen.</p>\n\n<p><strong>Q.</strong> REPLACE FACTOR!? REPLACE GAP!?<br />\n <strong>A.</strong> 8 and 2 were determined to be the most consistent options for baseline determination and adequate attenuation of events during replacement. Feel free to experiment, or leave them. </p>\n\n<p><strong>Q.</strong> Do we not require a lower Z-score for the estimate because of the event influence? \\\n<strong>A.</strong> No, the improved estimate is so accurate in the presence of outliers, it blew my socks off. So, we only need one Z-score for both estimation and iteration.</p>\n\n<p><strong>Q.</strong> What does the estimate accomplish?<br />\n<strong>A.</strong> The estimate will determine the cutoff for iteration and the direction of the events. Note, the direction is the starting point for iteration and will not be the final result. The final result <em>always</em> extracts biphasically. If you do not want events from a specific side, they are conveniently labelled in the results CSV.</p>\n"}, {"fullname": "notnormal.extract", "modulename": "notnormal.extract", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "notnormal.extract.initial_estimate", "modulename": "notnormal.extract", "qualname": "initial_estimate", "kind": "function", "doc": "<p>Provides an initial estimate for the maximum cutoff frequency and event direction for the iterate function. The output\nevents can also be used for wavelet filtering (notnormal.filter.methods.wavelet_filter). This is an improved version\nof the conventional event extraction method, using a robust sequence of iterations to make an initial estimate on\nthe event population. From this, automatic iteration can be performed with the maximised cutoff frequency and event\ndirection. The only required parameters are the input trace and sample_rate, with the estimate_cutoff frequency\nbeing the primary tuning parameter and ultimately decides how accurate the initial estimate is. Other parameters\nare provided for fine-tuning.</p>\n\n<p>Note: Both replace_factor and replace_gap as 0.0 indicates baseline replacement instead of individual replacement.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>trace (ndarray | Trace):</strong>  The input trace or a Trace object. If ndarray, the sample rate must be provided.</li>\n<li><strong>filtered_trace (ndarray | None):</strong>  The filtered version of the input trace, used for bounding events. If None,\nthe trace is used. Default is None.</li>\n<li><strong>sample_rate (int | None):</strong>  The sample rate of the trace. Has to be provided if trace is a ndarray. Default is None.</li>\n<li><strong>estimate_cutoff (float):</strong>  The initial estimate for the cutoff frequency. Default is 10.0.</li>\n<li><strong>replace_factor (float):</strong>  Factor for replacing events in the calculation trace. Default is 8.0.</li>\n<li><strong>replace_gap (float):</strong>  Gap for replacing events in the calculation trace. Default is 2.0.</li>\n<li><strong>threshold_window (float):</strong>  The window size for threshold calculation. Default is 2.0.</li>\n<li><strong>z_score (float | None):</strong>  The Z-score for event detection. If None, it is calculated based on the trace length.\nDefault is None.</li>\n<li><strong>output_features (str | None):</strong>  The output event features. Can be 'full' for absolute features, 'FWHM', or 'FWQM'\nfor full width at half maximum or quarter maximum, respectively. These apply to duration, area, and peak\namplitude. None specifies no events on the output. Default is 'full'.</li>\n<li><strong>vector_results (bool):</strong>  Whether to return vector results, this is very expensive. Default is False.</li>\n<li><strong>_validate (bool):</strong>  Whether to validate the inputs. Do not disable unless you have validated externally.\nDefault is True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>InitialEstimateResults: An object containing the initial estimate results.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">trace</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Trace</span>,</span><span class=\"param\">\t<span class=\"n\">filtered_trace</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">sample_rate</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">estimate_cutoff</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">10.0</span>,</span><span class=\"param\">\t<span class=\"n\">replace_factor</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">8.0</span>,</span><span class=\"param\">\t<span class=\"n\">replace_gap</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">threshold_window</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">z_score</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_features</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;full&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">vector_results</span><span class=\"p\">:</span> <span class=\"n\">bint</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">_validate</span><span class=\"p\">:</span> <span class=\"n\">bint</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">InitialEstimateResults</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.extract.iterate", "modulename": "notnormal.extract", "qualname": "iterate", "kind": "function", "doc": "<p>Performs iterative anomaly detection and baseline determination based on the input (maximised) cutoff frequency and\nevent direction deduced from initial_estimate. This function is an advanced version of the iterative method, built\nto be automatic when paired with the initial estimate. It uses various mechanisms to circumvent the downfalls\nof the maximised cutoff frequency, individual local replacement, automatic influence calculation, and an automatic\nstopping criterion, among other advancements. The only required parameters are the input trace, sample_rate, cutoff,\nand event_direction. The primary tuning parameters are the replace_factor and replace_gap, which determine how\naggressive the individual replacement is and how much the event samples influence the replacement. When Both\nreplace_factor and replace_gap are 0.0, baseline replacement is done instead of individual replacement. Other\nparameters are provided for fine-tuning.</p>\n\n<p>Note on the final extraction after iteration: When the stopping criterion is met, the (calc_trace - baseline) used\nin the previous iteration was the best for normality, so we use the event coordinates determined from that iteration\n(compared vs. best normality). The replacement of those coordinates then indicates that all events are replaced,\nso we use the calc_trace and baseline determined from this replacement. In other words, the calc_trace and baseline\nfrom the next iteration which triggered the stopping criterion. We then replace event locations in the baseline with\nthe calc_trace, as this is a locally optimal baseline once we are sure all events have been replaced. Then, a final\nthreshold is computed using the std method (more accurate without outliers) on the calc_trace - baseline, which is\nnow a fully removed trace. Thus, the final extraction is computed on the locally optimal baseline and threshold.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>trace (ndarray | Trace):</strong>  The input trace or a Trace object. If ndarray, the sample rate must be provided.</li>\n<li><strong>cutoff (float):</strong>  The cutoff frequency for the baseline filter derived from initial_estimate.</li>\n<li><strong>event_direction (str):</strong>  The direction of events ('up', 'down', or 'biphasic') derived from initial_estimate.</li>\n<li><strong>filtered_trace (ndarray | None):</strong>  The filtered version of the input trace, used for bounding events.\nIf None, the trace is used. Default is None.</li>\n<li><strong>sample_rate (int | None):</strong>  The sample rate of the trace. Has to be provided if trace is a ndarray. Default is None.</li>\n<li><strong>replace_factor (float):</strong>  Factor for replacing events in the calculation trace. Default is 8.0.</li>\n<li><strong>replace_gap (float):</strong>  Gap for replacing events in the calculation trace. Default is 2.0.</li>\n<li><strong>threshold_window (float):</strong>  The window size for threshold calculation. Default is 2.0.</li>\n<li><strong>z_score (float | None):</strong>  The Z-score for event detection. If None, it is calculated based on the trace length.\nDefault is None.</li>\n<li><strong>output_features (str | None):</strong>  The output event features. Can be 'full' for absolute features, 'FWHM', or 'FWQM'\nfor full width at half maximum or quarter maximum, respectively. These apply to duration, area, and peak\namplitude. None specifies no events on the output. Default is 'full'.</li>\n<li><strong>vector_results (bool):</strong>  Whether to return vector results, this is very expensive. Default is False.</li>\n<li><strong>_validate (bool):</strong>  Whether to validate the inputs. Do not disable unless you have validated externally.\nDefault is True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>IterateResults: An object containing the iterate results.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">trace</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Trace</span>,</span><span class=\"param\">\t<span class=\"n\">cutoff</span><span class=\"p\">:</span> <span class=\"n\">double</span>,</span><span class=\"param\">\t<span class=\"n\">event_direction</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">filtered_trace</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">sample_rate</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">replace_factor</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">8.0</span>,</span><span class=\"param\">\t<span class=\"n\">replace_gap</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">threshold_window</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">z_score</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_features</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;full&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">vector_results</span><span class=\"p\">:</span> <span class=\"n\">bint</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">_validate</span><span class=\"p\">:</span> <span class=\"n\">bint</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IterateResults</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.extract.not_normal", "modulename": "notnormal.extract", "qualname": "not_normal", "kind": "function", "doc": "<p>Anomaly detection and baseline determination for (nano)electrochemical time series data. This function combines\ninitial_estimate and iterate steps into a single function. There are no required parameters other than the input\ntrace and sample rate (or a Trace object). See: initial_estimate and iterate for further details.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>trace (ndarray | Trace):</strong>  The input trace or a Trace object. If ndarray, the sample rate must be provided.</li>\n<li><strong>sample_rate (int | None):</strong>  The sample rate of the trace. Has to be provided if trace is a ndarray. Default is None.</li>\n<li><strong>bounds_window (int):</strong>  The window size for the median filter used in bounding. Default is 3.</li>\n<li><strong>estimate_cutoff (float):</strong>  The initial estimate for the cutoff frequency. Default is 10.0.</li>\n<li><strong>replace_factor (float):</strong>  Factor for replacing events in the calculation trace. Default is 8.0.</li>\n<li><strong>replace_gap (float):</strong>  Gap for replacing events in the calculation trace. Default is 2.0.</li>\n<li><strong>threshold_window (float):</strong>  The window size for threshold calculation. Default is 2.0.</li>\n<li><strong>z_score (float | None):</strong>  The Z-score for event detection. If None, it is calculated based on the trace length.\nDefault is None.</li>\n<li><strong>output_features (str | None):</strong>  The output event features. Can be 'full' for absolute features, 'FWHM', or 'FWQM'\nfor full width at half maximum or quarter maximum, respectively. These apply to duration, area, and peak\namplitude. None specifies no events on the output. Default is 'full'.</li>\n<li><strong>vector_results (bool):</strong>  Whether to return vector results, this is very expensive. Default is False.</li>\n<li><strong>parallel (bool):</strong>  Whether to run the iteration in parallel. Default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple[IterateResults, InitialEstimateResults]: The iteration results object and initial estimate results object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">trace</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Trace</span>,</span><span class=\"param\">\t<span class=\"n\">sample_rate</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bounds_window</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">estimate_cutoff</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">10.0</span>,</span><span class=\"param\">\t<span class=\"n\">replace_factor</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">8.0</span>,</span><span class=\"param\">\t<span class=\"n\">replace_gap</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">threshold_window</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">z_score</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_features</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;full&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">vector_results</span><span class=\"p\">:</span> <span class=\"n\">bint</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">parallel</span><span class=\"p\">:</span> <span class=\"n\">bint</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IterateResults</span><span class=\"p\">,</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">InitialEstimateResults</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.extract.parallel_iterate", "modulename": "notnormal.extract", "qualname": "parallel_iterate", "kind": "function", "doc": "<p>Parallel equivalent to the iterate function.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>trace (ndarray | Trace):</strong>  The input trace or a Trace object. If ndarray, the sample rate must be provided.</li>\n<li><strong>cutoff (float):</strong>  The cutoff frequency for the baseline filter derived from initial_estimate.</li>\n<li><strong>event_direction (str):</strong>  The direction of events ('up', 'down', or 'biphasic') derived from initial_estimate.</li>\n<li><strong>filtered_trace (ndarray | None):</strong>  The filtered version of the input trace, used for bounding events.\nIf None, the trace is used. Default is None.</li>\n<li><strong>sample_rate (int | None):</strong>  The sample rate of the trace. Has to be provided if trace is a ndarray. Default is None.</li>\n<li><strong>replace_factor (float):</strong>  Factor for replacing events in the calculation trace. Default is 8.0.</li>\n<li><strong>replace_gap (float):</strong>  Gap for replacing events in the calculation trace. Default is 2.0.</li>\n<li><strong>threshold_window (float):</strong>  The window size for threshold calculation. Default is 2.0.</li>\n<li><strong>z_score (float | None):</strong>  The Z-score for event detection. If None, it is calculated based on the trace length.\nDefault is None.</li>\n<li><strong>output_features (str | None):</strong>  The output event features. Can be 'full' for absolute features, 'FWHM', or 'FWQM'\nfor full width at half maximum or quarter maximum, respectively. These apply to duration, area, and peak\namplitude. None specifies no events on the output. Default is 'full'.</li>\n<li><strong>vector_results (bool):</strong>  Whether to return vector results, this is not possible in parallel, but will assert on\nthe fallback to serial. Default is False.</li>\n<li><strong>segment_size (int | None):</strong>  Size of segments for parallel processing. Default is None and will calculate\nautomatically.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>IterateResults: An object containing the iterate results.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">trace</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Trace</span>,</span><span class=\"param\">\t<span class=\"n\">cutoff</span><span class=\"p\">:</span> <span class=\"n\">double</span>,</span><span class=\"param\">\t<span class=\"n\">event_direction</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">filtered_trace</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">sample_rate</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">replace_factor</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">8.0</span>,</span><span class=\"param\">\t<span class=\"n\">replace_gap</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">threshold_window</span><span class=\"p\">:</span> <span class=\"n\">double</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">z_score</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_features</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;full&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">vector_results</span><span class=\"p\">:</span> <span class=\"n\">bint</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">segment_size</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IterateResults</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.extract.simple_extractor", "modulename": "notnormal.extract", "qualname": "simple_extractor", "kind": "function", "doc": "<p>Extract the events from the trace based on the event coordinates and the baseline. Then, simple features are\ncalculated for each event. Duration is always in ms, while area and amplitude are in the same units as the trace.\nThat is, if the trace is in pA, we have pC and pA for area and amplitude, respectively.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>trace (ndarray):</strong>  The input signal trace or a Trace object.</li>\n<li><strong>baseline (ndarray):</strong>  The baseline of the trace.</li>\n<li><strong>event_coordinates (ndarray):</strong>  The coordinates of detected events.</li>\n<li><strong>sample_rate (int | None):</strong>  The sample rate of the trace. Has to be provided if trace is a ndarray. Default is None.</li>\n<li><strong>feature_type (str):</strong>  The output event features. Can be 'full' for absolute features, 'FWHM', or 'FWQM' for full\nwidth at half maximum or quarter maximum, respectively. These apply to duration, area, and peak amplitude.\nDefault is 'full'.</li>\n<li><strong>label (str):</strong>  The label for the Events object, if a Trace object is provided, that label takes precedence.\nDefault is ''.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Events: An Events object containing the extracted events and their features.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">trace</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Trace</span>,</span><span class=\"param\">\t<span class=\"n\">baseline</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">event_coordinates</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">sample_rate</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">feature_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;full&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">label</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Events</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.filter", "modulename": "notnormal.filter", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "notnormal.filter.inverse_partial_moswt", "modulename": "notnormal.filter", "qualname": "inverse_partial_moswt", "kind": "function", "doc": "<p>Perform the inverse partial MOSWT (additional unsplitting of the final two levels) on the coefficients.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>coeffs (list[ndarray]):</strong>  The partial MOSWT coefficients, in the form [cAn, cDn, ..., cD1].</li>\n<li><strong>wavelet (str):</strong>  The wavelet used for decomposition.</li>\n<li><strong>max_level (int):</strong>  The maximum level used for decomposition.</li>\n<li><strong>u_length (int):</strong>  Number of decomposition splits used for the ultimate level (must be 2^N). Default is 2.</li>\n<li><strong>p_length (int):</strong>  Number of decomposition splits used for the penultimate level (must be 2^N). Default is 2.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ndarray: The inverse partial MOSWT of the coefficients.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coeffs</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">wavelet</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">max_level</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">u_length</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">p_length</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.filter.partial_moswt", "modulename": "notnormal.filter", "qualname": "partial_moswt", "kind": "function", "doc": "<p>Perform the partial MOSWT (additional splitting of the final two levels) on the trace.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>trace (ndarray):</strong>  The trace to be decomposed or a Trace object.</li>\n<li><strong>wavelet (str):</strong>  The wavelet to use for decomposition, see pywavelets documentation for available wavelets.</li>\n<li><strong>max_level (int):</strong>  The maximum level of decomposition.</li>\n<li><strong>u_length (int):</strong>  Number of splits for the ultimate level (must be 2^N). Default is 2.</li>\n<li><strong>p_length (int):</strong>  Number of splits for the penultimate level (must be 2^N). Default is 2.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[ndarray]: List of coefficients from the trace decomposition, in the form [cAn, cDn, ..., cD1].</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">trace</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Trace</span>,</span><span class=\"param\">\t<span class=\"n\">wavelet</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">max_level</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">u_length</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">p_length</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.filter.wavelet_filter", "modulename": "notnormal.filter", "qualname": "wavelet_filter", "kind": "function", "doc": "<p>Perform predictive wavelet filtering using the partial MOSWT (additional splitting of the final two levels) on the\ntrace. First, the event lengths are used to determine the decomposition level such that the characteristic frequency\nof the events is captured, which is estimated via the q_pop parameter. The u_length and p_length parameters then\ncontrol the number of splits for the final two levels, giving more resolution in the critical bands where prominent\nevent power is located. Second, the events are used to build a float mask (event amplitude mask) to separate signal\nand noise in the wavelet coefficients, allowing highly accurate band specific SNR estimation and subsequent\ndenoising. To account for phase shifts in the standard cascade decomposition, as well as additional contributions\nfrom the tree-like decomposition, the event mask is also decomposed identically to the trace. From this, a robust\nintra-band mask is constructed allowing generalisation of the method to arbitrary wavelets for which computing the\nshift is infeasible. The q_thresh parameter controls the quantile threshold for the mask gating, accounting for\nlarge spread of the mask in the higher wavelet levels, which would otherwise overestimate the POI support. Finally,\nthe SNR thresholds are computed using BayesShrink with extreme value capping. The extreme value cap is analogous to\nthe single expected outlier in the two-sided distribution used in NotNormal, exploiting the known distribution to\nprevent large thresholds eliminating signal in levels where they are underrepresented in the population statistics.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>trace (ndarray | Trace):</strong>  The trace to be filtered or a Trace object.</li>\n<li><strong>events (Events):</strong>  An Events object containing events from the trace.</li>\n<li><strong>wavelet (str):</strong>  The wavelet to use, see pywavelets documentation for available wavelets.</li>\n<li><strong>u_length (int):</strong>  Number of splits for the ultimate level (must be 2^N). Default is 2.</li>\n<li><strong>p_length (int):</strong>  Number of splits for the penultimate level (must be 2^N). Default is 2.</li>\n<li><strong>q_pop (float):</strong>  Quantile of the population to estimate the characteristic event frequency in [0, 1]. Default is 0.5.</li>\n<li><strong>q_thresh (float):</strong>  Quantile threshold for mask gating in (0, 1). Default is 0.05.</li>\n<li><strong>mode (str):</strong>  The thresholding mode, 'soft' or 'hard'. Default is 'soft'.</li>\n<li><strong>full_results (bool):</strong>  Whether to return the wavelet coefficients in the results. Default is False.</li>\n<li><strong>verbose (bool):</strong>  Whether to print verbose output during processing. Default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>WaveletFilterResults: An object containing the filtering results.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">trace</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Trace</span>,</span><span class=\"param\">\t<span class=\"n\">events</span><span class=\"p\">:</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Events</span>,</span><span class=\"param\">\t<span class=\"n\">wavelet</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;sym2&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">u_length</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">p_length</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">q_pop</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">q_thresh</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;soft&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">full_results</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">WaveletFilterResults</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.gui", "modulename": "notnormal.gui", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "notnormal.gui.NN2", "modulename": "notnormal.gui.NN2", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "notnormal.gui.not_normal_gui", "modulename": "notnormal.gui.not_normal_gui", "kind": "module", "doc": "<p>This module is the GUI for the NotNormal algorithm. It is inefficient, has bugs, but it works and is functional.\nIn the future, it will be replaced with a more efficient and better designed GUI</p>\n"}, {"fullname": "notnormal.gui.not_normal_gui.CustomFigureCanvas", "modulename": "notnormal.gui.not_normal_gui", "qualname": "CustomFigureCanvas", "kind": "class", "doc": "<p>The canvas the figure renders into.</p>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>figure : <code>~matplotlib.figure.Figure</code>\n    A high-level figure instance.</p>\n", "bases": "matplotlib.backends.backend_tkagg.FigureCanvasTkAgg"}, {"fullname": "notnormal.gui.not_normal_gui.FeatureWindow", "modulename": "notnormal.gui.not_normal_gui", "qualname": "FeatureWindow", "kind": "class", "doc": "<p>Toplevel widget, e.g. for dialogs.</p>\n", "bases": "tkinter.Toplevel"}, {"fullname": "notnormal.gui.not_normal_gui.FeatureWindow.__init__", "modulename": "notnormal.gui.not_normal_gui", "qualname": "FeatureWindow.__init__", "kind": "function", "doc": "<p>Construct a widget with the parent widget MASTER, a name WIDGETNAME\nand appropriate options.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">master</span>, </span><span class=\"param\"><span class=\"n\">events</span></span>)</span>"}, {"fullname": "notnormal.gui.not_normal_gui.NotNormalGUI", "modulename": "notnormal.gui.not_normal_gui", "qualname": "NotNormalGUI", "kind": "class", "doc": "<p>Toplevel widget of Tk which represents mostly the main window\nof an application. It has an associated Tcl interpreter.</p>\n", "bases": "tkinter.Tk"}, {"fullname": "notnormal.gui.not_normal_gui.NotNormalGUI.__init__", "modulename": "notnormal.gui.not_normal_gui", "qualname": "NotNormalGUI.__init__", "kind": "function", "doc": "<p>Return a new top level widget on screen SCREENNAME. A new Tcl interpreter will\nbe created. BASENAME will be used for the identification of the profile file (see\nreadprofile).\nIt is constructed from sys.argv[0] without extensions if None is given. CLASSNAME\nis the name of the widget class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "notnormal.models", "modulename": "notnormal.models", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "notnormal.models.EventAugmentationArgs", "modulename": "notnormal.models", "qualname": "EventAugmentationArgs", "kind": "class", "doc": "<p>A dataclass to represent the parameters for event augmentation. See: notnormal.reconstruct.events.augment_clusters.</p>\n"}, {"fullname": "notnormal.models.EventAugmentationArgs.to_dict", "modulename": "notnormal.models", "qualname": "EventAugmentationArgs.to_dict", "kind": "function", "doc": "<p>Convert the EventAugmentationArgs object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the EventAugmentationArgs object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.Events", "modulename": "notnormal.models", "qualname": "Events", "kind": "class", "doc": "<p>A dataclass to represent a collection of events.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>label (str):</strong>  The label for the events.</li>\n<li><strong>events (dict[int, dict[str, Any]]):</strong>  A dictionary of event dictionaries keyed by event ID.</li>\n<li><strong>feature_type (str):</strong>  The type of features computed for the events. Default is 'Full'.</li>\n<li><strong>_ids (set[int]):</strong>  Internal attribute storing the used IDs.</li>\n<li><strong>_schema (set[str] | None):</strong>  Internal attribute storing the expected keys of the event schema.</li>\n<li><strong>_req_keys (set[str]):</strong>  Internal attribute storing the required keys for each event.</li>\n</ul>\n"}, {"fullname": "notnormal.models.Events.add", "modulename": "notnormal.models", "qualname": "Events.add", "kind": "function", "doc": "<p>Add an event dictionary to the events list.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>event (dict[str, Any]):</strong>  The event dictionary to add.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.Events.get", "modulename": "notnormal.models", "qualname": "Events.get", "kind": "function", "doc": "<p>Get an event dictionary by its ID.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>event_id (int):</strong>  The ID of the event dictionary to retrieve.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: The event dictionary with the specified ID.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.Events.remove", "modulename": "notnormal.models", "qualname": "Events.remove", "kind": "function", "doc": "<p>Remove an event dictionary by its ID.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>event_id (int):</strong>  The ID of the event dictionary to remove.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.Events.get_feature", "modulename": "notnormal.models", "qualname": "Events.get_feature", "kind": "function", "doc": "<p>Get a feature from all event dictionaries, optionally filtering by event ID or a custom filter function.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>key (str):</strong>  The key of the feature to retrieve.</li>\n<li><strong>event_ids (list[int] | None):</strong>  A list of event IDs to retrieve the feature from. Default is None (all events).</li>\n<li><strong>filter_fn (Callable[[dict], bool] | None):</strong>  Optional callable that takes an event dict and returns True to include it. Default is None (no filtering).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Any]: A list of feature values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">event_ids</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">filter_fn</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">dict</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.Events.get_features", "modulename": "notnormal.models", "qualname": "Events.get_features", "kind": "function", "doc": "<p>Get multiple features from all event dictionaries, optionally filtering by event ID or a custom filter function.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>keys (list[str]):</strong>  A list of keys for the features to retrieve.</li>\n<li><strong>event_ids (list[int] | None):</strong>  A list of event IDs to retrieve the features from. Default is None (all events).</li>\n<li><strong>filter_fn (Callable[[dict], bool] | None):</strong>  Optional callable that takes an event dict and returns True to include it. Default is None (no filtering).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, list[Any]]: A dictionary where keys are feature names and values are lists of feature values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">keys</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">event_ids</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">filter_fn</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">dict</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.Events.add_feature", "modulename": "notnormal.models", "qualname": "Events.add_feature", "kind": "function", "doc": "<p>Add a feature to all event dictionaries.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>key (str):</strong>  The key of the feature to add.</li>\n<li><strong>value (ndarray):</strong>  The values of the feature to add.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.Events.add_features", "modulename": "notnormal.models", "qualname": "Events.add_features", "kind": "function", "doc": "<p>Add multiple features to all event dictionaries.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>features (dict[str, ndarray]):</strong>  A dictionary of features to add.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.Events.to_dict", "modulename": "notnormal.models", "qualname": "Events.to_dict", "kind": "function", "doc": "<p>Convert the Events object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the Events object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.InitialEstimateArgs", "modulename": "notnormal.models", "qualname": "InitialEstimateArgs", "kind": "class", "doc": "<p>A dataclass to represent the parameters for initial estimation. See: notnormal.extract.methods.initial_estimate.</p>\n"}, {"fullname": "notnormal.models.InitialEstimateArgs.to_dict", "modulename": "notnormal.models", "qualname": "InitialEstimateArgs.to_dict", "kind": "function", "doc": "<p>Convert the InitialEstimateArgs object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the InitialEstimateArgs object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.InitialEstimateResults", "modulename": "notnormal.models", "qualname": "InitialEstimateResults", "kind": "class", "doc": "<p>A dataclass that represents the results of initial estimation on the trace.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>args (InitialEstimateArgs):</strong>  The arguments used for initial estimation.</li>\n<li><strong>event_direction (str | None):</strong>  The estimated event direction, either 'up' or 'down'. Default is None.</li>\n<li><strong>max_cutoff (float | None):</strong>  The estimated maximum cutoff that can be used for iteration. Default is None.</li>\n<li><strong>initial_threshold (ndarray | None):</strong>  The initial threshold from event detection. Default is None.</li>\n<li><strong>events (Events):</strong>  The final detected events. Default is None.</li>\n<li><strong>iterations (list[Iteration2]):</strong>  A list of Iteration2 objects representing each iteration. Default is an empty list.</li>\n</ul>\n"}, {"fullname": "notnormal.models.InitialEstimateResults.to_dict", "modulename": "notnormal.models", "qualname": "InitialEstimateResults.to_dict", "kind": "function", "doc": "<p>Convert the InitialEstimateResults object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the InitialEstimateResults object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.IterateArgs", "modulename": "notnormal.models", "qualname": "IterateArgs", "kind": "class", "doc": "<p>A dataclass to represent the parameters for initial estimation. See: notnormal.extract.methods.iterate.</p>\n"}, {"fullname": "notnormal.models.IterateArgs.to_dict", "modulename": "notnormal.models", "qualname": "IterateArgs.to_dict", "kind": "function", "doc": "<p>Convert the IterateArgs object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the IterateArgs object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.IterateResults", "modulename": "notnormal.models", "qualname": "IterateResults", "kind": "class", "doc": "<p>A dataclass that represents the results of iteration on the trace.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>args (IterateArgs):</strong>  The arguments used for iteration.</li>\n<li><strong>initial_threshold (ndarray | None):</strong>  The initial threshold from event detection. Default is None.</li>\n<li><strong>events (Events):</strong>  The final detected events. Default is None.</li>\n<li><strong>iterations (list[Iteration2]):</strong>  A list of Iteration2 objects representing each iteration. Default is an empty list.</li>\n</ul>\n"}, {"fullname": "notnormal.models.IterateResults.to_dict", "modulename": "notnormal.models", "qualname": "IterateResults.to_dict", "kind": "function", "doc": "<p>Convert the IterateResults object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the IterateResults object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.Iteration", "modulename": "notnormal.models", "qualname": "Iteration", "kind": "class", "doc": "<p>A dataclass to represent an iteration of event detection and baseline determination.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>calculation_trace (ndarray | None):</strong>  The trace used for baseline and threshold calculations. Default is None.</li>\n<li><strong>baseline (ndarray | None):</strong>  The baseline of the trace. Default is None.</li>\n<li><strong>threshold (ndarray | None):</strong>  The threshold for event detection. Default is None.</li>\n<li><strong>trace_stats (dict[str, float] | None):</strong>  Statistics for the baseline adjusted calculation trace.</li>\n<li><strong>event_coordinates (ndarray | None):</strong>  The coordinates of detected events. Default is None.</li>\n<li><strong>event_stats (dict[str, float | int] | None):</strong>  Population statistics for the detected events.</li>\n</ul>\n"}, {"fullname": "notnormal.models.Iteration.to_dict", "modulename": "notnormal.models", "qualname": "Iteration.to_dict", "kind": "function", "doc": "<p>Convert the Iteration object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the Iteration object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.NoiseFitResults", "modulename": "notnormal.models", "qualname": "NoiseFitResults", "kind": "class", "doc": "<p>A dataclass to represent the results of noise fitting.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>n_regimes (int):</strong>  The number of regimes in the noise model.</li>\n<li><strong>f (ndarray):</strong>  The frequency array of the true noise used for fitting.</li>\n<li><strong>pxx (ndarray):</strong>  The power spectral density (PSD) array of the true noise used for fitting.</li>\n<li><strong>p_filter (ndarray):</strong>  The power response of the anti-aliasing filter used for fitting.</li>\n<li><strong>cs (list[float]):</strong>  The frequency domain numerators (directly related to variance) of the noise regimes.</li>\n<li><strong>ms (list[float]):</strong>  The frequency domain exponents (directly related to H) of the noise regimes.</li>\n<li><strong>alphas (list[float]):</strong>  The detrended fluctuation analysis (DFA) alpha exponents (directly related to H) of the noise regimes.</li>\n<li><strong>SSLE (float):</strong>  The SSLE (objective value) of the fit.</li>\n<li><strong>success (bool):</strong>  Whether the fitting was successful.</li>\n<li><strong>global_opt (Any):</strong>  The global optimisation result of the fit.</li>\n<li><strong>local_opt (Any):</strong>  The local optimisation result of the fit.</li>\n<li><strong>SAM (float):</strong>  The spectral angular map value of the fit.</li>\n<li><strong>total (ndarray | None):</strong>  The total generated noise. Default is None.</li>\n<li><strong>regimes (dict[float, ndarray] | None):</strong>  The individually generated noise regimes keyed by alpha value. Default is None.</li>\n</ul>\n"}, {"fullname": "notnormal.models.NoiseFitResults.get_line_fit", "modulename": "notnormal.models", "qualname": "NoiseFitResults.get_line_fit", "kind": "function", "doc": "<p>Get the line fit for the noise model.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple[ndarray, ndarray]: The line fit for the noise model and each individual component.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.NoiseFitResults.to_dict", "modulename": "notnormal.models", "qualname": "NoiseFitResults.to_dict", "kind": "function", "doc": "<p>Convert the NoiseFitResults object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the NoiseFitResults object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.NoiseReconstructResults", "modulename": "notnormal.models", "qualname": "NoiseReconstructResults", "kind": "class", "doc": "<p>A dataclass to represent the results of noise reconstruction.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>args (NoiseReconstructionArgs):</strong>  The arguments used for reconstruction.</li>\n<li><strong>fits (dict[int, NoiseFitResults]):</strong>  All noise fitting results keyed by the number of regimes.</li>\n<li><strong>best_fit (NoiseFitResults | None):</strong>  The best fitting results. Default is None.</li>\n<li><strong>loss_curves (dict[str, tuple[ndarray, ndarray]] | None):</strong>  Loss curves for the fitting results. Default is None.</li>\n</ul>\n"}, {"fullname": "notnormal.models.NoiseReconstructResults.to_dict", "modulename": "notnormal.models", "qualname": "NoiseReconstructResults.to_dict", "kind": "function", "doc": "<p>Convert the NoiseReconstructionResults object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the NoiseReconstructionResults object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.NoiseReconstructionArgs", "modulename": "notnormal.models", "qualname": "NoiseReconstructionArgs", "kind": "class", "doc": "<p>A dataclass to represent the parameters for noise reconstruction. See: notnormal.reconstruct.noise.reconstruct_noise.</p>\n"}, {"fullname": "notnormal.models.NoiseReconstructionArgs.to_dict", "modulename": "notnormal.models", "qualname": "NoiseReconstructionArgs.to_dict", "kind": "function", "doc": "<p>Convert the NoiseReconstructionArgs object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the NoiseReconstructionArgs object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.ShapeCluster", "modulename": "notnormal.models", "qualname": "ShapeCluster", "kind": "class", "doc": "<p>A dataclass to represent a single cluster of event vectors.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>label (int):</strong>  The cluster label.</li>\n<li><strong>confidence (float):</strong>  Average assignment confidence.</li>\n<li><strong>vectors (list[ndarray]):</strong>  The original event vectors assigned to this cluster.</li>\n<li><strong>weights (ndarray):</strong>  The assignment probabilities for each event vector to this cluster.</li>\n<li><strong>representative (ndarray | None):</strong>  The representative vector for the cluster. Default is None.</li>\n<li><strong>normalised (ndarray | None):</strong>  The cluster specific normalised vectors. Default is None.</li>\n<li><strong>reconstructed (list[ndarray] | None):</strong>  Reconstructed event vectors. Default is None.</li>\n<li><strong>loss (dict[str, float] | None):</strong>  Reconstruction loss metrics.</li>\n<li><strong>local_model (Any | None):</strong>  The local scaling feature model. Default is None.</li>\n<li><strong>sampled_durations (ndarray | list[int] | None):</strong>  The sampled durations. Default is None.</li>\n<li><strong>sampled_areas (ndarray | list[float] | None):</strong>  The sampled areas. Default is None.</li>\n<li><strong>augmented (list[ndarray] | None):</strong>  Augmented event vectors. Default is None.</li>\n</ul>\n"}, {"fullname": "notnormal.models.ShapeCluster.to_dict", "modulename": "notnormal.models", "qualname": "ShapeCluster.to_dict", "kind": "function", "doc": "<p>Convert the Cluster object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the Cluster object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.ShapeClusterArgs", "modulename": "notnormal.models", "qualname": "ShapeClusterArgs", "kind": "class", "doc": "<p>A dataclass to represent the parameters for shape clustering. See: notnormal.reconstruct.events.shape_cluster.</p>\n"}, {"fullname": "notnormal.models.ShapeClusterArgs.to_dict", "modulename": "notnormal.models", "qualname": "ShapeClusterArgs.to_dict", "kind": "function", "doc": "<p>Convert the ShapeClusteringArgs object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the ShapeClusteringArgs object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.ShapeClusterResults", "modulename": "notnormal.models", "qualname": "ShapeClusterResults", "kind": "class", "doc": "<p>A dataclass to represent the results of shape clustering.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>args (ShapeClusterArgs):</strong>  The arguments used for clustering.</li>\n<li><strong>fits (dict[int, ShapeClusters]):</strong>  All clustering results keyed by the number of clusters.</li>\n<li><strong>area_norm (ndarray | None):</strong>  Globally area + length normalised event vectors. Default is None.</li>\n<li><strong>length_norm (ndarray | None):</strong>  Globally length normalised event vectors. Default is None.</li>\n<li><strong>transform (ndarray | None):</strong>  Globally transformed + normalised event vectors. Default is None.</li>\n<li><strong>umap (Any | None):</strong>  The UMAP object used for dimensionality reduction. Default is None.</li>\n<li><strong>best_fit (ShapeClusters):</strong>  The best clustering result. Default is None.</li>\n<li><strong>loss_curves (dict[str, tuple[ndarray, ndarray]] | None):</strong>  Loss curves for the clustering results. Default is None.</li>\n<li><strong>knees (dict[str, ndarray] | None):</strong>  The knee points for the clustering results. Default is None.</li>\n</ul>\n"}, {"fullname": "notnormal.models.ShapeClusterResults.to_dict", "modulename": "notnormal.models", "qualname": "ShapeClusterResults.to_dict", "kind": "function", "doc": "<p>Convert the ShapeClusterResults object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the ShapeClusterResults object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.ShapeClusters", "modulename": "notnormal.models", "qualname": "ShapeClusters", "kind": "class", "doc": "<p>A dataclass to represent the output of shape clustering, possibly including reconstruction and augmentation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>k (int):</strong>  The number of clusters.</li>\n<li><strong>model (any):</strong>  The GaussianMixture instance.</li>\n<li><strong>bic (float):</strong>  The Bayesian Information Criterion value of the GMM.</li>\n<li><strong>labels (ndarray):</strong>  The cluster labels assigned to each event vector.</li>\n<li><strong>probabilities (ndarray):</strong>  The full GMM assignment probability matrix (N x K).</li>\n<li><strong>clusters (list[ShapeCluster]):</strong>  List of ShapeCluster objects holding detailed cluster data.</li>\n<li><strong>mean_loss (dict[str, float] | None):</strong>  Global mean reconstruction loss metrics. Default is None.</li>\n<li><strong>distributional_loss (dict[str, float] | None):</strong>  Distributional loss metrics across clusters. Default is None.</li>\n<li><strong>global_model (Any | None):</strong>  The global model scaling feature model. Default is None.</li>\n<li><strong>args (EventAugmentationArgs):</strong>  The arguments used for event augmentation.</li>\n<li><strong>sampled_model (ndarray | None):</strong>  The sampled transformed + normalised event vectors. Default is None.</li>\n<li><strong>sample_labels (ndarray | None):</strong>  The sampled labels. Default is None.</li>\n<li><strong>aug_distributional_loss (dict[str, float] | None):</strong>  Augmentation distributional loss metrics across clusters. Default is None.</li>\n</ul>\n"}, {"fullname": "notnormal.models.ShapeClusters.get_vectors", "modulename": "notnormal.models", "qualname": "ShapeClusters.get_vectors", "kind": "function", "doc": "<p>Get the event vectors for all clusters or a specific cluster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cluster_id (int | None):</strong>  The ID of a specific cluster. Default is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[ndarray]: A list of event vectors for all clusters or the specified cluster.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cluster_id</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.ShapeClusters.get_representative", "modulename": "notnormal.models", "qualname": "ShapeClusters.get_representative", "kind": "function", "doc": "<p>Get representative vectors for all clusters or a specific cluster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cluster_id (int | None):</strong>  The ID of a specific cluster. Default is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ndarray: All representative vectors or only for the specified cluster.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cluster_id</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.ShapeClusters.get_normalised", "modulename": "notnormal.models", "qualname": "ShapeClusters.get_normalised", "kind": "function", "doc": "<p>Get the locally normalised event vectors for all clusters or a specific cluster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cluster_id (int | None):</strong>  The ID of a specific cluster. Default is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ndarray: An array of locally normalised event vectors for all clusters or the specified cluster.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cluster_id</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.ShapeClusters.get_reconstructed", "modulename": "notnormal.models", "qualname": "ShapeClusters.get_reconstructed", "kind": "function", "doc": "<p>Get the reconstructed event vectors for all clusters or a specific cluster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cluster_id (int | None):</strong>  The ID of a specific cluster. Default is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[ndarray]: A list of reconstructed event vectors for all clusters or the specified cluster.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cluster_id</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.ShapeClusters.get_augmented", "modulename": "notnormal.models", "qualname": "ShapeClusters.get_augmented", "kind": "function", "doc": "<p>Get the augmented event vectors for all clusters or a specific cluster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cluster_id (int | None):</strong>  The ID of a specific cluster. Default is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[ndarray]: A list of augmented event vectors for all clusters or the specified cluster.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cluster_id</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.ShapeClusters.to_dict", "modulename": "notnormal.models", "qualname": "ShapeClusters.to_dict", "kind": "function", "doc": "<p>Convert the ShapeClusters object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the ShapeClusters object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.Trace", "modulename": "notnormal.models", "qualname": "Trace", "kind": "class", "doc": "<p>A dataclass to represent a trace.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>label (str):</strong>  The label for the trace.</li>\n<li><strong>trace (ndarray):</strong>  The trace data.</li>\n<li><strong>sample_rate (int):</strong>  The sample rate of the trace.</li>\n<li><strong>units (str):</strong>  The units of the trace. Default is 'pA'.</li>\n<li><strong>path (str | None):</strong>  The file path where the trace is stored. Default is None.</li>\n<li><strong>time_step (float | None):</strong>  The time step between samples in the trace. Default is None.</li>\n<li><strong>samples (int | None):</strong>  The number of samples in the trace. Default is None.</li>\n<li><strong>duration (float | None):</strong>  The duration of the trace in seconds. Default is None.</li>\n</ul>\n"}, {"fullname": "notnormal.models.Trace.get_time_vector", "modulename": "notnormal.models", "qualname": "Trace.get_time_vector", "kind": "function", "doc": "<p>Get the time vector for the trace.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ndarray: The time vector for the trace.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.Trace.to_dict", "modulename": "notnormal.models", "qualname": "Trace.to_dict", "kind": "function", "doc": "<p>Convert the Trace object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the Trace object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.WaveletFilterArgs", "modulename": "notnormal.models", "qualname": "WaveletFilterArgs", "kind": "class", "doc": "<p>A dataclass to represent the parameters for wavelet filtering. See: notnormal.filter.methods.wavelet_filter.</p>\n"}, {"fullname": "notnormal.models.WaveletFilterArgs.to_dict", "modulename": "notnormal.models", "qualname": "WaveletFilterArgs.to_dict", "kind": "function", "doc": "<p>Convert the WaveletFilterArgs object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the WaveletFilterArgs object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.models.WaveletFilterResults", "modulename": "notnormal.models", "qualname": "WaveletFilterResults", "kind": "class", "doc": "<p>A dataclass that represents the results of a wavelet filter applied to a trace.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>args (WaveletFilterArgs):</strong>  The arguments used for filtering.</li>\n<li><strong>filtered_trace (ndarray):</strong>  The filtered trace.</li>\n<li><strong>max_level (int):</strong>  The calculated maximum level of decomposition.</li>\n<li><strong>lengths (ndarray):</strong>  The event lengths used for maximum level calculation.</li>\n<li><strong>signal_vars (ndarray):</strong>  The estimated signal variance for each band.</li>\n<li><strong>noise_vars (ndarray):</strong>  The estimated noise variance for each band.</li>\n<li><strong>thresholds (list[float]):</strong>  The calculated threshold for each band. Default is None.</li>\n<li><strong>coeffs (list[ndarray] | None):</strong>  The wavelet coefficients for the trace. Default is None.</li>\n<li><strong>coeffs_mask (list[ndarray] | None):</strong>  The wavelet coefficients for the event mask. Default is None.</li>\n<li><strong>filtered_coeffs (list[ndarray] | None):</strong>  The filtered wavelet coefficients for the trace. Default is None.</li>\n</ul>\n"}, {"fullname": "notnormal.models.WaveletFilterResults.to_dict", "modulename": "notnormal.models", "qualname": "WaveletFilterResults.to_dict", "kind": "function", "doc": "<p>Convert the WaveletFilterResults object to a dictionary representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: A dictionary representation of the WaveletFilterResults object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.reconstruct", "modulename": "notnormal.reconstruct", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "notnormal.reconstruct.augment_clusters", "modulename": "notnormal.reconstruct", "qualname": "augment_clusters", "kind": "function", "doc": "<p>Augment the event vectors using the representative vectors and scaling features derived from both local and global\nmodels. This function extends shape clustering by generating new event vectors based on the representative vectors\n(which encode the shapes in the population and their density) and the scales at which those shapes are observed.\nDistributional estimates of the global scaling features enables sampling of new scales that are consistent with the\nshape agnostic scaling features, providing an accurate representation of the overall population. Cluster specific\n(local) estimates enables sampling of scales consistent with each specific shape (representative vector), but\nprovide a less accurate estimate under the sparser subset of events. By using density aware rejection sampling on\nboth global and local models, scaling features can be sampled which respect both the overall and shape specific\ndistribution of scales. In this way, augmented events can be generated which respect shape, the scales those shapes\nare observed at, and the distribution of scales in the entire population. Note, the sample_global parameter controls\nwhich model is sampled from, with samples being accepted if the log likelihood ratio between the not sampled and\nsampled models exceeds a threshold. When True, the local model has a higher weighting, when False, the global\nmodel has a higher weighting, see: _sample_log_method.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>clusters (ShapeClusters):</strong>  An object containing the clustering results.</li>\n<li><strong>n_vectors (int | None):</strong>  The number of vectors to generate. If None, one generation will occur per event in\nShapeClusters. Default is None.</li>\n<li><strong>max_k (int):</strong>  The maximum number of components to fit (scaling features). Default is 50.</li>\n<li><strong>weight (float):</strong>  The weight concentration prior for the Dirichlet Process (scaling features). Default is 1e-2.</li>\n<li><strong>random_state (int | None):</strong>  Random seed for reproducibility (scaling features only). Default is None.</li>\n<li><strong>max_attempts (int):</strong>  The maximum number of attempts to sample a candidate. Default is 100.</li>\n<li><strong>sample_global (bool):</strong>  Whether to sample from the global model or the local model. Default is True.</li>\n<li><strong>dist_losses (bool):</strong>  Whether to compute the augmentation distributional losses. Default is True.</li>\n<li><strong>verbose (bool):</strong>  Whether to print verbose output during processing. Default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ShapeClusters: The input clustering results with augmentation results added.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">clusters</span><span class=\"p\">:</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">ShapeClusters</span>,</span><span class=\"param\">\t<span class=\"n\">n_vectors</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_k</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">50</span>,</span><span class=\"param\">\t<span class=\"n\">weight</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_attempts</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">sample_global</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">dist_losses</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">ShapeClusters</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.reconstruct.fit_noise", "modulename": "notnormal.reconstruct", "qualname": "fit_noise", "kind": "function", "doc": "<p>Fit noise regimes to the provided power spectral density (PSD) using global differential evolution optimisation\nfollowed by local L-BFGS-B optimisation. The fitting is done by minimising the sum of squared log error between the\npredicted and actual PSDs, taking into account the true anti-aliasing filter.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>f (ndarray):</strong>  The frequency array of the true noise.</li>\n<li><strong>pxx (ndarray):</strong>  The PSD array of the true noise.</li>\n<li><strong>aa_order (int):</strong>  The order of the anti-aliasing filter.</li>\n<li><strong>aa_cutoff (int):</strong>  The cutoff frequency for the anti-aliasing filter.</li>\n<li><strong>n_regimes (int | list[int]):</strong>  The number of noise regimes to fit or a list of noise regime numbers to fit. Default is (2, 3).</li>\n<li><strong>maxiter (tuple[int, int]):</strong>  The maximum number evaluations for differential evolution and L-BFGS-B. Default is (2000, 10000).</li>\n<li><strong>popsize (int):</strong>  The population size multiplier for differential evolution. Default is 500.</li>\n<li><strong>mutation (tuple[float, float]):</strong>  The mutation constant for differential evolution. Default is (0.7, 1.2).</li>\n<li><strong>random_state (int | None):</strong>  Random seed for reproducibility. Default is None.</li>\n<li><strong>verbose (bool):</strong>  Whether to print verbose output during processing. Default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[int, NoiseFitResults]: A dictionary of noise fitting results keyed by the number of regimes.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">f</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">pxx</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">aa_order</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">aa_cutoff</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_regimes</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">maxiter</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">2000</span><span class=\"p\">,</span> <span class=\"mi\">10000</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">popsize</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">500</span>,</span><span class=\"param\">\t<span class=\"n\">mutation</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">1.2</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">NoiseFitResults</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.reconstruct.generate_noise", "modulename": "notnormal.reconstruct", "qualname": "generate_noise", "kind": "function", "doc": "<p>Generate a composition of noise regimes based on the provided alpha and c values using a modified version of the\nspectral method. Optionally applies an anti-aliasing filter to the generated noise to match the conditions of the\ntrace the values were derived from.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>alphas (ndarray[float]):</strong>  The detrended fluctuation analysis (DFA) alpha exponents (directly related to H) of the noise regimes.</li>\n<li><strong>cs (ndarray[float]):</strong>  The frequency domain numerators (directly related to variance) of the noise regimes.</li>\n<li><strong>length (int):</strong>  The length of the noise regimes to generate.</li>\n<li><strong>sample_rate (int):</strong>  The sample rate of the noise regimes.</li>\n<li><strong>complex_gen (bool):</strong>  Whether to generate noise regimes starting with complex noise. Default is False.</li>\n<li><strong>psd_period (float | None):</strong>  The period of the power spectral density (PSD) for scale matching. Default is None.</li>\n<li><strong>nfft (int | None):</strong>  The number of PSD FFT points for scale matching. Default is None.</li>\n<li><strong>aa_cutoff (int | None):</strong>  The cutoff frequency for the anti-aliasing filter. Default is None.</li>\n<li><strong>aa_order (int | None):</strong>  The order of the anti-aliasing filter. Default is None.</li>\n<li><strong>random_state (int | None):</strong>  Random seed for reproducibility. Default is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple[ndarray, dict[float, ndarray]]: A tuple containing the total generated noise and a dictionary of individual\n  noise regimes keyed by their alpha values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">alphas</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">cs</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">length</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">sample_rate</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">complex_gen</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">psd_period</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nfft</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">aa_cutoff</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">aa_order</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.reconstruct.piecwise_fit_noise", "modulename": "notnormal.reconstruct", "qualname": "piecwise_fit_noise", "kind": "function", "doc": "<p>Fit piecewise linear noise regimes to the provided power spectral density (PSD) using Nelder-Mead optimisation.\nThe fitting is done by minimising the mean squared error between the predicted and actual PSDs. This function\ndoes not take into the account the anti-aliasing filter parameters, does not fit summed noise regimes, and does not\ngenerate. It is a simpler fitting method that can be used for quick estimates of the noise regimes, for diagnostic\npurposes, or for visualisation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>f (ndarray):</strong>  The frequency array of the true noise.</li>\n<li><strong>pxx (ndarray):</strong>  The PSD array of the true noise.</li>\n<li><strong>n_regimes (int | list[int]):</strong>  The number of noise regimes to fit or a list of noise regime numbers to fit. Default is (2, 3).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[int, dict[str, Any]]: A dictionary of noise fitting results keyed by the number of regimes.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">f</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">pxx</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">n_regimes</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.reconstruct.reconstruct_noise", "modulename": "notnormal.reconstruct", "qualname": "reconstruct_noise", "kind": "function", "doc": "<p>This function uses global differential evolution optimisation and local L-BFGS-B optimisation to fit a composition\nof noise regimes to the power spectral density (PSD) of the noise, given by the trace without events. The fitting\naccounts for the anti-aliasing filter parameters, enabling an accurate fit which respects the condition of the noise\npost-sampling. Following, each individual noise regime is generated using a modified version of the spectral method\nthat expands into the negative detrended fluctuation analysis (DFA) alpha and applies post-generation scaling to\nmaximise the accuracy of each individual regime. Finally, the composition is computed, the anti-aliasing filter is\napplied by estimating the Bessel filter using the window design method, and the spectral angular map (SAM) against\nthe true noise is computed to evaluate the quality of the reconstruction.</p>\n\n<p>Note: This function is computationally expensive. It is recommended to drop popsize to 50 or lower to get an estimate\non the number of regimes, confirm solely the best fit with a conservative PSD period (e.g. 0.1 s) and then run a\nhigher popsize (e.g. 500) with a longer PSD period (e.g. 1-2 s) to get the best fit for the noise regimes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>trace (ndarray | Trace):</strong>  The trace to be processed or a Trace object. If ndarray, the sample rate must be provided.</li>\n<li><strong>event_mask (ndarray | Events):</strong>  A boolean mask indicating the events in the trace or an Events object.</li>\n<li><strong>n_regimes (int | list[int]):</strong>  The number of noise regimes to fit or a list of noise regime numbers to fit. Default is [2, 3].</li>\n<li><strong>aa_order (int):</strong>  The order of the anti-aliasing filter.</li>\n<li><strong>aa_cutoff (int):</strong>  The cutoff frequency for the anti-aliasing filter.</li>\n<li><strong>sample_rate (int | None):</strong>  The sample rate of the trace. Has to be provided if trace is a ndarray. Default is None.</li>\n<li><strong>maxiter (tuple[int, int]):</strong>  The maximum number evaluations for differential evolution and L-BFGS-B. Default is (2000, 10000).</li>\n<li><strong>popsize (int):</strong>  The population size multiplier for differential evolution. Default is 500.</li>\n<li><strong>mutation (tuple[float, float]):</strong>  The mutation constant for differential evolution. Default is (0.7, 1.2).</li>\n<li><strong>psd_period (float | None):</strong>  The period for the PSD calculation. Default is None.</li>\n<li><strong>nfft (int | None):</strong>  The length of FFT to use for PSD calculation. Default is None.</li>\n<li><strong>generate (str | bool):</strong>  Whether to generate noise regimes. If 'Best', only the best fit is generated. Default is 'best'.</li>\n<li><strong>complex_gen (bool):</strong>  Whether to generate noise regimes starting with complex noise. Default is False.</li>\n<li><strong>random_state (int | None):</strong>  Random seed for reproducibility. Default is None.</li>\n<li><strong>verbose (bool):</strong>  Whether to print verbose output during processing. Default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>NoiseReconstructResults: An object containing the reconstruction results.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">trace</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Trace</span>,</span><span class=\"param\">\t<span class=\"n\">event_mask</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Events</span>,</span><span class=\"param\">\t<span class=\"n\">aa_cutoff</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">aa_order</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_regimes</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">sample_rate</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">maxiter</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">2000</span><span class=\"p\">,</span> <span class=\"mi\">10000</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">popsize</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">500</span>,</span><span class=\"param\">\t<span class=\"n\">mutation</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">1.2</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">psd_period</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nfft</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">generate</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;best&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">complex_gen</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">NoiseReconstructResults</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.reconstruct.shape_cluster", "modulename": "notnormal.reconstruct", "qualname": "shape_cluster", "kind": "function", "doc": "<p>Shape cluster event vectors using Uniform Manifold Approximation and Projection, along with representative vector\ncomputation and subsequent reconstruction losses. The algorithm comes from the simple idea of shape being the\nprincipal encoder of analyte identity, with different scales representing different modes of transport and\ninteraction. Each clustering operation produces a set of representative vectors from which the original event\nvectors are reconstructed to yield reconstruction losses. The optimal number of clusters is determined by\nthe point of diminishing returns in reconstruction loss, with the associated representative vectors encoding the\nshapes in the population.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>vectors (list[ndarray] | ndarray | Events):</strong>  The event vectors to cluster. Should be 2D array-like or Events\nobject. If Events object, direction must be specified. Otherwise, vectors must be monophasic, but not\nrequired to be strictly one-sided.</li>\n<li><strong>k (int | list[int]):</strong>  Number of clusters or list of cluster numbers. Default is range(2, 21).</li>\n<li><strong>direction (int | None):</strong>  The direction of the events. Has to be provided if vectors is an Events object, otherwise\nignored. Default is None.</li>\n<li><strong>n_components (int):</strong>  Number of latent space dimensions (UMAP). Default is 10.</li>\n<li><strong>metric (str):</strong>  Metric to compute distances (UMAP). Default is 'cosine'.</li>\n<li><strong>spread (float):</strong>  The effective scale of embedded points (UMAP). Default is 1.0.</li>\n<li><strong>min_dist (float):</strong>  The effective minimum distance between embedded points (UMAP). Default is 0.0.</li>\n<li><strong>n_neighbors (int):</strong>  Size of the local neighbourhood (UMAP). Default is 5.</li>\n<li><strong>random_state (int | None):</strong>  Random seed for reproducibility (UMAP, GMM). Default is None.</li>\n<li><strong>init_params (str):</strong>  The method used to initialise the weights (GMM). Default is 'kmeans'.</li>\n<li><strong>max_iter (int):</strong>  Number of EM iterations (GMM). Default is 100.</li>\n<li><strong>n_init (int):</strong>  Number of initialisations (GMM). Default is 1.</li>\n<li><strong>reconstruct (bool):</strong>  Whether to reconstruct the event vectors from their representative vector. Default is True.</li>\n<li><strong>sigma (float):</strong>  The noise standard deviation for interpretability and stability. Default is 0.0.</li>\n<li><strong>align (bool):</strong>  Whether to align the vectors before calculating losses. Default is True.</li>\n<li><strong>dist_losses (bool):</strong>  Whether to compute the reconstruction distributional losses. Default is True.</li>\n<li><strong>full_results (bool):</strong>  Whether to return the globally normalised + transformed vectors in the results. Default is False.</li>\n<li><strong>verbose (bool):</strong>  Whether to print verbose output during processing. Default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ShapeClusterResults: An object containing the clustering results.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vectors</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Events</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">13</span><span class=\"p\">,</span> <span class=\"mi\">14</span><span class=\"p\">,</span> <span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"mi\">17</span><span class=\"p\">,</span> <span class=\"mi\">18</span><span class=\"p\">,</span> <span class=\"mi\">19</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">direction</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_components</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">metric</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;cosine&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">spread</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">min_dist</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">n_neighbors</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">init_params</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;kmeans&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">n_init</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">reconstruct</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">sigma</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">align</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">dist_losses</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">full_results</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">ShapeClusterResults</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.simulate", "modulename": "notnormal.simulate", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "notnormal.simulate.simulate_baseline", "modulename": "notnormal.simulate", "qualname": "simulate_baseline", "kind": "function", "doc": "<p>Simulate a baseline.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>length (int):</strong>  The length of the baseline.</li>\n<li><strong>sample_rate (int):</strong>  The sample rate of the trace.</li>\n<li><strong>voltage (float):</strong>  The initial voltage offset of the baseline.</li>\n<li><strong>resistance (float, optional):</strong>  The initial resistance.</li>\n<li><strong>change (float, optional):</strong>  The change in the resistance over time.</li>\n<li><strong>cottrell_numerator (float, optional):</strong>  The numerator of the Cottrell equation.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: The simulated baseline.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">length</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">sample_rate</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">voltage</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">resistance</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">change</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cottrell_numerator</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "notnormal.simulate.simulate_events", "modulename": "notnormal.simulate", "qualname": "simulate_events", "kind": "function", "doc": "<p>Simulate events.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>amplitude (float):</strong>  The mean amplitude of the events.</li>\n<li><strong>amplitude_std (float):</strong>  The standard deviation of the event amplitudes.</li>\n<li><strong>duration (float):</strong>  The mean duration of the events in milliseconds.</li>\n<li><strong>duration_std (float):</strong>  The standard deviation of the event durations in milliseconds.</li>\n<li><strong>window (str):</strong>  The window function to use for the event shape, 'mixed' for different types.</li>\n<li><strong>direction (str):</strong>  The direction of the events ('up' or 'down').</li>\n<li><strong>event_number (int):</strong>  The number of events to simulate.</li>\n<li><strong>sample_rate (int):</strong>  The sample rate of the trace.</li>\n<li><strong>random_state (int | None):</strong>  Seed for the random number generator for reproducibility. Default is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: A list of simulated event dictionaries.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">amplitude</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">amplitude_std</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">duration</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">duration_std</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">window</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">direction</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">event_number</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">sample_rate</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "notnormal.simulate.simulate_regime", "modulename": "notnormal.simulate", "qualname": "simulate_regime", "kind": "function", "doc": "<p>Simulate a single noise regime.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>alpha (float):</strong>  The alpha parameter for the noise, alpha = -0.5 is the special capacitive noise case.</li>\n<li><strong>sigma (float):</strong>  The standard deviation of the noise.</li>\n<li><strong>length (int):</strong>  The length of the noise regime.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ndarray: The simulated noise regime.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">sigma</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">length</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "notnormal.simulate.simulate_trace", "modulename": "notnormal.simulate", "qualname": "simulate_trace", "kind": "function", "doc": "<p>Simulate a trace with noise, baseline, and events.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>length (int):</strong>  The length of the trace.</li>\n<li><strong>sample_rate (int):</strong>  The sample rate of the trace.</li>\n<li><strong>noise_dict (dict, optional):</strong>  Dictionary containing noise parameters with 'regimes' in the format</li>\n<li><strong>(alpha, crossover frequency) and 'sigma' specifying the overall sigma. See:</strong>  simulate_regime(). Default is None.</li>\n<li><strong>baseline_dict (dict, optional):</strong>  Dictionary containing baseline parameters. See: simulate_baseline().</li>\n<li>Default is None.</li>\n<li><strong>event_dicts (list[dict], optional):</strong>  List of dictionaries containing event parameters. See: simulate_events().</li>\n<li>Default is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: A tuple containing the trace, coordinate trace, events, and baseline.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">length</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">sample_rate</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">noise_dict</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">baseline_dict</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">event_dicts</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "notnormal.utils", "modulename": "notnormal.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "notnormal.utils.combine_noise_events", "modulename": "notnormal.utils", "qualname": "combine_noise_events", "kind": "function", "doc": "<p>This function combines reconstructed/augmented noise (notnormal.reconstruct.reconstruct_noise) with reconstructed/\naugmented event vectors (notnormal.reconstruct.shape_cluster/augment_clusters) into a single trace. If coordinates\nare provided, the events are added at those specific locations. If no coordinates are provided, the function\nrandomly places the events in the noise trace uniformly without replacement.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>noise (ndarray):</strong>  The reconstructed or augmented noise.</li>\n<li><strong>vectors (list[ndarray]):</strong>  The reconstructed or augmented event vectors.</li>\n<li><strong>coordinates (list[tuple[int, int]] | Events):</strong>  List of tuple event coordinates or an Events object. Default is None.</li>\n<li><strong>max_attempts (int):</strong>  If random placement, how many attempts to place the events before giving up. Default is 100.</li>\n<li><strong>random_state (int | None):</strong>  Random seed for reproducibility. Default is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple[ndarray, Optional[ndarray]]: The noise with the events added and a boolean event mask.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">noise</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">vectors</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Events</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_attempts</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.utils.get_event_mask", "modulename": "notnormal.utils", "qualname": "get_event_mask", "kind": "function", "doc": "<p>Build a boolean or float (event locations inplace) event mask for the input trace. Note, the float mask is only\nbaseline corrected if an Events object is provided, whereby the actual vector is inserted. Otherwise, the coordinates\nfrom the input trace are inserted.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>trace (ndarray | Trace):</strong>  The trace or a Trace object.</li>\n<li><strong>coordinates (list[tuple[int, int]] | Events):</strong>  List of tuple event coordinates or an Events object.</li>\n<li><strong>float_mask (bool):</strong>  If True, return a float mask instead of a boolean mask. Default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ndarray: Boolean or float event mask.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">trace</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Trace</span>,</span><span class=\"param\">\t<span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Events</span>,</span><span class=\"param\">\t<span class=\"n\">float_mask</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.utils.get_psd", "modulename": "notnormal.utils", "qualname": "get_psd", "kind": "function", "doc": "<p>Compute the power spectral density (PSD) of a given trace using Welch's method.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>trace (ndarray | Trace):</strong>  The trace to be processed or a Trace object.</li>\n<li><strong>sample_rate (int | None):</strong>  The sample rate of the trace. Has to be provided if trace is a ndarray. Default is None.</li>\n<li><strong>fmin (float | None):</strong>  The minimum frequency for the PSD. Default is None.</li>\n<li><strong>fmax (float | None):</strong>  The maximum frequency for the PSD. Default is None.</li>\n<li><strong>psd_period (float | None):</strong>  The period for the PSD calculation. Default is None.</li>\n<li><strong>nfft (int | None):</strong>  The length of FFT to use. Default is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple[ndarray, ndarray]: The frequency array and PSD array for the trace.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">trace</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Trace</span>,</span><span class=\"param\">\t<span class=\"n\">sample_rate</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fmin</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fmax</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">psd_period</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nfft</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "notnormal.utils.load_trace", "modulename": "notnormal.utils", "qualname": "load_trace", "kind": "function", "doc": "<p>Load a trace from its path. Currently, it supports Axon binary format (.abf) and separated values formats\n(.csv, .tsv, .txt, .dat). The expected format for separated values files is: | Time (s) | Current (pA) |, with or\nwithout a header. Support for FAST5/SLOW5 etc. will be added on request.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  Path to the trace file.</li>\n<li><strong>label (Optional[str]):</strong>  Label for the trace. If not provided, the file name without extension is used. Default is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Trace: A Trace object containing the trace and trace information.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">label</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">notnormal</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Trace</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();